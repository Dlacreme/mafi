# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strict
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/ffi/all/ffi.rbi
#
# ffi-1.14.1

module FFI
  def self.add_typedef(old, add); end
  def self.errno; end
  def self.errno=(error); end
  def self.find_type(name, type_map = nil); end
  def self.map_library_name(lib); end
  def self.type_size(type); end
  def self.typedef(old, add); end
end
class FFI::PlatformError < LoadError
end
module FFI::Platform
  def self.bsd?; end
  def self.is_os(os); end
  def self.mac?; end
  def self.solaris?; end
  def self.unix?; end
  def self.windows?; end
end
module FFI::DataConverter
  def from_native(value, ctx); end
  def native_type(type = nil); end
  def to_native(value, ctx); end
end
class FFI::StrPtrConverter
  def self.from_native(val, ctx); end
  extend FFI::DataConverter
end
class FFI::NotFoundError < LoadError
  def initialize(function, *libraries); end
end
module FFI::Library
  def attach_function(name, func, args, returns = nil, options = nil); end
  def attach_variable(mname, a1, a2 = nil); end
  def bitmask(*args); end
  def callback(*args); end
  def enum(*args); end
  def enum_type(name); end
  def enum_value(symbol); end
  def ffi_convention(convention = nil); end
  def ffi_lib(*names); end
  def ffi_lib_flags(*flags); end
  def ffi_libraries; end
  def find_type(t); end
  def function_names(name, arg_types); end
  def generic_enum(klass, *args); end
  def self.extended(mod); end
  def typedef(old, add, info = nil); end
end
class FFI::AbstractMemory
  def size_limit?; end
end
class FFI::Pointer < FFI::AbstractMemory
  def read(type); end
  def read_array_of_type(type, reader, length); end
  def read_string(len = nil); end
  def read_string_length(len); end
  def read_string_to_null; end
  def self.size; end
  def to_ptr; end
  def write(type, value); end
  def write_array_of_type(type, writer, ary); end
  def write_string(str, len = nil); end
  def write_string_length(str, len); end
end
class FFI::StructLayout < FFI::Type
  def offset_of(field_name); end
  def offsets; end
end
class FFI::StructLayout::Enum < FFI::StructLayout::Field
  def get(ptr); end
  def put(ptr, value); end
end
class FFI::StructLayout::InnerStruct < FFI::StructLayout::Field
  def get(ptr); end
  def put(ptr, value); end
end
class FFI::StructLayout::Mapped < FFI::StructLayout::Field
  def get(ptr); end
  def initialize(name, offset, type, orig_field); end
  def put(ptr, value); end
end
class FFI::StructLayoutBuilder
  def add(name, type, offset = nil); end
  def add_array(name, type, count, offset = nil); end
  def add_field(name, type, offset = nil); end
  def add_struct(name, type, offset = nil); end
  def align(offset, align); end
  def alignment; end
  def alignment=(align); end
  def build; end
  def field_for_type(name, offset, type); end
  def initialize; end
  def packed=(packed); end
  def size; end
  def size=(size); end
  def union=(is_union); end
  def union?; end
end
class FFI::StructByReference
  def from_native(value, ctx); end
  def initialize(struct_class); end
  def native_type; end
  def struct_class; end
  def to_native(value, ctx); end
  include FFI::DataConverter
end
class FFI::Struct
  def align; end
  def alignment; end
  def clear; end
  def members; end
  def offset_of(name); end
  def offsets; end
  def self.align(alignment = nil); end
  def self.aligned(alignment = nil); end
  def self.alignment; end
  def self.array_layout(builder, spec); end
  def self.auto_ptr; end
  def self.by_ref(flags = nil); end
  def self.by_value; end
  def self.callback(params, ret); end
  def self.enclosing_module; end
  def self.find_field_type(type, mod = nil); end
  def self.find_type(type, mod = nil); end
  def self.hash_layout(builder, spec); end
  def self.in; end
  def self.layout(*spec); end
  def self.members; end
  def self.offset_of(name); end
  def self.offsets; end
  def self.out; end
  def self.pack(packed = nil); end
  def self.packed(packed = nil); end
  def self.ptr(flags = nil); end
  def self.size; end
  def self.size=(size); end
  def self.val; end
  def size; end
  def to_ptr; end
  def values; end
end
class FFI::Struct::ManagedStructConverter < FFI::StructByReference
  def from_native(ptr, ctx); end
  def initialize(struct_class); end
end
class FFI::Union < FFI::Struct
  def self.builder; end
end
class FFI::ManagedStruct < FFI::Struct
  def initialize(pointer = nil); end
end
module FFI::IO
  def self.for_fd(fd, mode = nil); end
  def self.native_read(io, buf, len); end
end
class FFI::AutoPointer < FFI::Pointer
  def autorelease=(autorelease); end
  def autorelease?; end
  def free; end
  def initialize(ptr, proc = nil, &block); end
  def self.from_native(val, ctx); end
  def self.native_type; end
  extend FFI::DataConverter
end
class FFI::AutoPointer::Releaser
  def autorelease; end
  def autorelease=(arg0); end
  def call(*args); end
  def free; end
  def initialize(ptr, proc); end
end
class FFI::AutoPointer::DefaultReleaser < FFI::AutoPointer::Releaser
  def release(ptr); end
end
class FFI::AutoPointer::CallableReleaser < FFI::AutoPointer::Releaser
  def release(ptr); end
end
class FFI::VariadicInvoker
  def attach(mod, mname); end
  def call(*args, &block); end
  def init(arg_types, type_map); end
end
class FFI::Enums
  def <<(enum); end
  def __map_symbol(symbol); end
  def find(query); end
  def initialize; end
end
class FFI::Enum
  def [](query); end
  def find(query); end
  def from_native(val, ctx); end
  def initialize(*args); end
  def native_type; end
  def symbol_map; end
  def symbols; end
  def tag; end
  def to_h; end
  def to_hash; end
  def to_native(val, ctx); end
  include FFI::DataConverter
end
class FFI::Bitmask < FFI::Enum
  def [](*query); end
  def from_native(val, ctx); end
  def initialize(*args); end
  def to_native(query, ctx); end
end
